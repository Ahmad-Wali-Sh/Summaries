`Part 1: Chapter 1`

> **Computer Software:**
> 	The Product that software professionals build and then support over the long term. programs execute within a computer of any size and architecture.

> **Software Engineering:**
> 	A Process, a collection of methods (practice) and an array of tools that allow professionals to build high quality computer software.
> 	
> 	> Why Matter:
> 	> Enables us to build complex systems in a timely manner and with high quality.
> 

> *You can have it fast, you can have it right, or you can have it cheap. pick two!*
> 	- Roger S. Pressman

*Computer Software continues to be the single most important technology on the world stage.*

### 1.1 The Nature of Software

Software nowadays has a dual role, it is a product, at the same time, the vehicle for delivering a product.

As a *Product*, it delivers the computing potentials. an **information transformer**.

As The *Vehicle*, as the basis of controlling the computer (Operating System), the communication of information (networks), and the creation and control of other programs (software tools and environments).

Software delivers the most important product of out time - **Information**

#### 1.1.1 Defining Software

> 1: Set of instructions that when executed provide desired features, function and performance. 

> 2: Data structures that enable the programs to adequately manipulate information.

> 3: descriptive information in both hard copy and virtual forms that describes the operation and use of the programs.

**Characteristics:**
		1. Software is developed or engineered:
		2. Software doesn't "wear out.", but deteriorate!			
		3. it is not physical the wear out by the time, but any error is produced from                bad engineering.
		4. merely component-based construction, mostly custom build
			1. A software component should be designed and implemented to be used in many different programs.


#### 1.1.2 Software Application Domains

`Seven Broad categories of computer software`

1. System Software:
	1. A Collection of programs written to service other programs. (OS, compliers, editors, file managers, drivers, networking software, telecommunications processors)
2. Application Software:
	1. Stand-alone programs that solve a specific business need. (Facilitate business operations and management)
	2. (POS in real time and more)
3. Engineering/Scientific Software:
	1. Applications range from astronomy to volcanology
4. Embedded Software:
	1. Resides within a product or system and it is used to empower it.
5. Product-line Software:
	1. design to provide a specific capability for use by many different customers
	2. inventory control products or address mass consumer markets (word processing, spreadsheets and more)
6. Web Applications:
	1. WebApps, the network-centric spans a wide array of applications worldwide
7. Artificial Intelligence software:
	1. makes use of nonnumerical algorithms to solve complex problems. image recognition and voice recognition.

Challenges:
	Open-World Computing:
		The Rapid growth of wireless networking may soon lead to true pervasive, distributed computing, to develop systems that will allow mobile, personal computers and enterprise systems to communicate.
	Netsourcing:
		to architect simple and sophisticated application that provide a benefit to targeted end-user markets
	Open-Source:
		Growing makes people contribute to programs, challenge is for software engineers to use techniques to insure both developer and customers that which parts changed and how to use them.

### Legacy Software

Legacy software systems . . . were developed decades ago and continually modified to meet changes in business. costly to maintain, risky to evolve.

### The Unique Nature of WebApps

Web-based systems and applications were born after the creation of HTML, XML, Java and more.

`Web-based systmes and applications "involve a mixture between print publishing and and software development, between marketing and computing, between internal communication and external relations, and between art and technology"`

1. *Network intensiveness*: resides on network (local or wide)
2. *Concurrency:* Parallel Usage
3. *Unpredictable load:* users between 1 to 1000000 in one day
4. *Performance:* not taking too long or user leaves.
5. *Availability:* 24/7/365 
6. *Data Driven:* for audio, video, texts and data.
7. *Content sensitive:* Aesthetic nature of content
8. *Continues evolution:* minute-by-minute and continues updates
9. *immediacy:* time-to-market that can be matter of days or weeks
10. *Security:* Strong security must be implemented
11. *Aesthetics:* undeniable part of the appeal of WebApp is its look and feel

### 1.3 Software Engineering

Few Simple Realities:
1. Software embedded in every aspect of life.
2. The Information technology requirements grow increasing complex with each passing year.
3. Individuals, business and government increasingly rely on software for strategic and tactical decision making day-by-day.
4. As the perceived value of a specific application grows, longevity grows. so it should be maintainable.

*Software in every domain should be engineered.* 

> Software Engineering:
> 	>The establishment and use of sound engineering principles in order to obtain economically software that is reliable and works efficiently on real machines.
> 	
> 	> The Application of a systematic, disciplined, quantifiable approach to the development, operation, and maintenance of software; that is, the application of engineering to software. (with adaptability and agility)
> 	

`Software Engineering: Tools -> Methods -> Process -> A Quality focus`

> **Process:** The Foundation of software engineering.* which puts layers together.

> **Methods:** provide the technical how-to's.

> **Tools** provide automated or semiautomated support for the process and methods for a *Computer-aided software engineering* approach.

### 1.4 The Software Process

> *Process:* is a collection of activities, actions, and tasks that are performed when some work product is to be created. (Activity, Action and Task) 

Five Generic Process Framework activities:

1. Communication:
	1. Before Any Technical Work. Communication to stakeholders and customers. 
2. Planning:
	1. Any complicated journey can be simplified if a map exists. that is called a software project plan.
	2. defines: 
		1. technical tasks
		2. risks
		3. resources
		4. work schedule 
		5. timeline
3. Modeling:
	1. creating a "sketch" of the thig so that you'll understand the big picture
	2. for better understanding software requirements and the design that will achieve those requirements.
4. Construction:
	1. Code Generation.
	2. Testing
5. Deployment:
	1. Software as a complete entity or as a partially completed increment is delivered to the customer.

Umbrella activities:
1. Software Project tracking and control.
2. Risk Management
3. Software Quality Assurance
4. Technical Reviews
5. Measurement
6. Software configuration management
7. Reusability management
8. Work Product preparation and production

### 1.5 Software Engineering Practice

#### 1.5.1 The Essence of Practice

How to solving a problem, become the essence of software engineering practice

1. Understand the problem (communication and analysis)
2. Plan A solution (Modeling and software design)
3. Carry out the plan (Code Generation)
4. Examine the result for accuracy (Testing and quality assurance)
#### 1.5.2 General Principles

> Principle: an important underlying law or assumption required in a system of thought. 

`Hooker Seven Principles:`
1. The Reason It All Exists
	1. To provide value to its users.
2. KISS (Keep It Simple, Stupid!)
	1. All Design should be simple as possible, but not simpler.
	2. Easily understood and easily maintainable.
3. Maintain a Vision
	1. having an empowered architect. 
4. What You Produce, Others Will Consume
	1. Someone will use, document, develop or depend on what you have built.
5. Be Open to the Future
	1. A System with a long lifetime has more value.
	2. must be adaptable for the future.
6. Plan Ahead For Reuse
	1. Reuse saves time and effort. 
7. Think!
	1. *Placing Clear, Complete Thought before action almost always produces better results.*

### 1.6 Software Myths

Some Realities:
- There is No Standard Book For Software Engineering
- We Can't Add programmers late and think Project Going To End Faster
- Outsourcing the project to third party not make you relax
- A general statement of objectives is not sufficient for building a product
- Changes Not Apply Anytime in The Project
- Once You write the code, job is not done.
- Software Engineering not slowing you down but it helps quality and timeline.




